param ACCELERATION = 1.0;
param BRAKE = 2.0;
param NEUTRAL = 0.0;
param TIMER_INIT = 5;
param DANGER = 1;
param OK = 0;
param INIT_SPEED_V1 = 25.0;
param INIT_SPEED_V2 = 25.0;
param MAX_SPEED = 40.0;
param MAX_SPEED_OFFSET = 0.2;
param INIT_DISTANCE_OBS_V1 = 10000.0;
param INIT_DISTANCE_V1_V2 = 5000.0;
param MAX_DISTANCE_OFFSET = 1.0;
param SAFETY_DISTANCE = 200.0;
param ETA_fast = 0.05;
param ETA_slow = 0.1;
param ETA_comb = 0.1;
param ETA_crash_speed = 0.1;


function new_timer (int timer){
  return timer - 1;
}

function new_distance (real dist, real travel){
 return dist - travel;
}

function eval_bd (real speed){
  return (speed^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * speed * TIMER_INIT)) / (2 * BRAKE);
}

function eval_rd (real speed){
  return eval_bd(speed) + SAFETY_DISTANCE;
}


function effectOf(accel_type v) {
    if (v == ACCELERATION) {
        return 1.0;
    } else {
        if (v == NEUTRAL) {
            return 0.0;
        } else {
            return -1.0;
        }
    }
}

function crash_probability (real dist){
  if (dist > 0){
    return 0.0;
  } else {
    return 1.0;
  }
}

function crash_speed(int collision, real dist_object, real dist_vehicles, real speed){
  if (collision == 0 && (dist_object <=0 || dist_vehicles <=0)){
    return speed/MAX_SPEED;
  } else {
    return 0.0;
  }
}

function slow_speed(real speed, real offs){
  return max(0, speed - offs);
}

function fast_speed(real speed, real offs){
  return max(0, speed + offs);
}



global variables{
  real p_speed_V1 range [0,MAX_SPEED] = INIT_SPEED_V1;
  real p_distance_V1 range [0,INIT_DISTANCE_OBS_V1] = INIT_DISTANCE_OBS_V1;
  int timer_V1 range [0,TIMER_INIT] = 0;
  real braking_distance_V1 range [0, INIT_DISTANCE_OBS_V1] = (INIT_SPEED_V1^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V1 * TIMER_INIT)) / (2 * BRAKE);
  real required_distance_V1 range [0, INIT_DISTANCE_OBS_V1] = (INIT_SPEED_V1^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V1 * TIMER_INIT)) / (2 * BRAKE) + SAFETY_DISTANCE;
  real safety_gap_V1 range [0, INIT_DISTANCE_OBS_V1] = INIT_DISTANCE_OBS_V1 - (INIT_SPEED_V1^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V1 * TIMER_INIT)) / (2 * BRAKE) - SAFETY_DISTANCE;
  real p_speed_V2 range [0,MAX_SPEED] = INIT_SPEED_V2;
  real p_distance_V2 range [0,INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2] = INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2;
  real p_distance_V1_V2 range [0,INIT_DISTANCE_V1_V2] = INIT_DISTANCE_V1_V2;
  int timer_V2 range [0,TIMER_INIT] = 0;
  real braking_distance_V2 range [0, INIT_DISTANCE_V1_V2] = (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT)) / (2 * BRAKE);
  real required_distance_V2 range [0, INIT_DISTANCE_V1_V2] = (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT)) / (2 * BRAKE) + SAFETY_DISTANCE;
  real safety_gap_V2 range [0, INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2] = INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2 - (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT)) / (2 * BRAKE) - SAFETY_DISTANCE;
  real safety_gap_V1_V2 range [0, INIT_DISTANCE_V1_V2] = INIT_DISTANCE_V1_V2 - (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT)) / (2 * BRAKE) - SAFETY_DISTANCE;
  real offset_speed_V1 range [0,MAX_SPEED*MAX_SPEED_OFFSET] = 0.0;
  real offset_speed_V2 range [0,MAX_SPEED*MAX_SPEED_OFFSET] = 0.0;
  real offset_distance range [0,INIT_DISTANCE_V1_V2*MAX_DISTANCE_OFFSET] = 0.0;
}


component Vehicle1 {
  variables{
    real s_speed_V1 range [0,MAX_SPEED] = 25.0;
    real s_distance_V1 range [0,INIT_DISTANCE_OBS_V1] = INIT_DISTANCE_OBS_V1;
    real accel_V1 range [-BRAKE,ACCELERATION]= NEUTRAL;
    int warning_V1 range [0,1] = 0;
    int brake_light_V1 range [0,1] = 0;
    int crashed_V1 range [0,1] = 0;
  }
  controller {
    state Ctrl_V1 {
      if (s_speed_V1 > 0) {
        if (safety_gap_V1 > 0) {
          accel_V1' = ACCELERATION;
          timer_V1' = TIMER_INIT;
          brake_light_V1' = 0;
          step Accelerate_V1;
        } else {
          accel_V1' = - BRAKE;
          timer_V1' = TIMER_INIT;
          brake_light_V1' = 1;
          step Decelerate_V1;
        }
      } else {
        accel_V1' = NEUTRAL;
        timer_V1' = TIMER_INIT;
        step Stop_V1;
      }
    }
    state Accelerate_V1 {
      if (timer_V1 > 0) {
        step Accelerate_V1;
      } else {
        exec Ctrl_V1;
      }
    }
    state Decelerate_V1 {
      if (timer_V1 > 0) {
        step Decelerate_V1;
      } else {
        exec Ctrl_V1;
      }
    }
    state Stop_V1 {
      if (timer_V1 > 0) {
        step Stop_V1;
      } else {
        if (warning_V1 == DANGER) {
          accel_V1' = -BRAKE;
          timer_V1' = TIMER_INIT;
          brake_light_V1' = 1;
          step Decelerate_V1;
        } else {
          timer_V1' = TIMER_INIT;
          step Stop_V1;
        }
      }
    }
    state IDS_V1 {
      if (p_distance_V1 <= 2*TIMER_INIT*SAFETY_DISTANCE && (accel_V1 == ACCELERATION || (accel_V1 == NEUTRAL && p_speed_V1 > 0.0))) {
        warning_V1' = DANGER;
        step IDS_V1;
      } else {
        warning_V1' = OK;
        step IDS_V1;
      }
    }
  }
  init Ctrl_V1 || IDS_V1
}

component Vehicle2 {
  variables{
    real s_speed_V2 range [0,MAX_SPEED] = 25.0;
    real s_distance_V2 range [0,INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2] = INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2;
    real s_distance_V1_V2 range [0,INIT_DISTANCE_V1_V2] = INIT_DISTANCE_V1_V2;
    real accel_V2 range [-BRAKE,ACCELERATION] = NEUTRAL;
    int warning_V2 range [0,1] = 0;
    int brake_light_V2 range [0,1] = 0;
    int crashed_V2 range [0,1] = 0;
  }
  controller {
    state Ctrl_V2 {
      if (s_speed_V2 > 0) {
        if (safety_gap_V1_V2 > 0 && (brake_light_V1 == 0 || (s_distance_V1_V2 >= 300 && safety_gap_V2 > 0 ))) {
          accel_V2' = ACCELERATION;
          timer_V2' = TIMER_INIT;
          brake_light_V2' = 0;
          step Accelerate_V2;
        } else {
          accel_V2' = - BRAKE;
          timer_V2' = TIMER_INIT;
          brake_light_V2' = 1;
          step Decelerate_V2;
        }
      } else {
        accel_V2' = NEUTRAL;
        timer_V2' = TIMER_INIT;
        step Stop_V2;
      }
    }
    state Accelerate_V2 {
      if (timer_V2 > 0) {
        step Accelerate_V2;
      } else {
        exec Ctrl_V2;
      }
    }
    state Decelerate_V2 {
      if (timer_V2 > 0) {
        step Decelerate_V2;
      } else {
        exec Ctrl_V2;
      }
    }
    state Stop_V2 {
      if (timer_V2 > 0) {
        step Stop_V2;
      } else {
        if (warning_V2 == DANGER) {
          accel_V2' = -BRAKE;
          timer_V2' = TIMER_INIT;
          brake_light_V2' = 1;
          step Decelerate_V2;
        } else {
          timer_V2' = TIMER_INIT;
          step Stop_V2;
        }
      }
    }
    state IDS_V2 {
      if (p_distance_V2 <= 2*TIMER_INIT*SAFETY_DISTANCE && (accel_V2 == ACCELERATION || (accel_V2 == NEUTRAL && p_speed_V2 > 0.0))) {
        warning_V2' = DANGER;
        step IDS_V2;
      } else {
        warning_V2' = OK;
        step IDS_V2;
      }
    }
  }
  init Ctrl_V2 || IDS_V2
}

environment {
  let
    travel_V1 = effectOf(accel_V1)/2 + p_speed_V1
  and
    travel_V2 = effectOf(accel_V2)/2 + p_speed_V2
  and
    new_p_speed_V1 = min(MAX_SPEED, max(0, p_speed_V1 + accel_V1))
  and
    new_p_speed_V2 = min(MAX_SPEED, max(0, p_speed_V2 + accel_V2))
  in {
    timer_V1' = new_timer(timer_V1);
    p_speed_V1' = new_p_speed_V1;
    p_distance_V1' = new_distance(p_distance_V1,travel_V1);
    timer_V2' = new_timer(timer_V2);
    p_speed_V2' = new_p_speed_V2;
    p_distance_V2' = new_distance(p_distance_V2, travel_V2);
    p_distance_V1_V2' = new_distance(p_distance_V1_V2, travel_V2 - travel_V1);
    if (new_timer(timer_V1) == 0) {
      braking_distance_V1' = eval_bd(new_p_speed_V1);
      required_distance_V1' = eval_rd(new_p_speed_V1);
      safety_gap_V1' = new_distance(p_distance_V1, travel_V1) - eval_rd(new_p_speed_V1);
      s_speed_V1' = new_p_speed_V1;
      s_distance_V1' = new_distance(p_distance_V1, travel_V1);
    }
    if (new_timer(timer_V2) == 0) {
      braking_distance_V2' = eval_bd(new_p_speed_V2);
      required_distance_V2' = eval_rd(new_p_speed_V2);
      safety_gap_V2' = new_distance(p_distance_V2, travel_V2) - eval_rd(new_p_speed_V2);
      safety_gap_V1_V2' = new_distance(p_distance_V1_V2, travel_V2 - travel_V1) - eval_rd(new_p_speed_V2);
      s_speed_V2' = new_p_speed_V2;
      s_distance_V2' = new_distance(p_distance_V2, travel_V2);
      s_distance_V1_V2' = new_distance(p_distance_V1_V2, travel_V2 - travel_V1);
    }
    when (p_distance_V1 <= 0)
      crashed_V1' = 1;
    when (p_distance_V2 <= 0 || p_distance_V1_V2 <=0)
      crashed_V2' = 1;
  }
}

penalty rho_crash = crash_probability(p_distance_V1_V2)

penalty rho_crash_speed = crash_speed(crashed_V2, p_distance_V2, p_distance_V1_V2, p_speed_V2)

penalty rho_speed = p_speed_V2

distance exp_crash = \G[350,450] < rho_crash;

distance exp_crash_speed = \G[10,400] < rho_crash_speed;

perturbation p_ItSlow = ([offset_speed_V2 <- p_speed_V2 * MAX_SPEED_OFFSET * R[0,1]]@0); (p_slow)^150;

perturbation p_slow = [offset_speed_V2 <- p_speed_V2 * MAX_SPEED_OFFSET * R[0,1],
                       s_speed_V2 <- fake_speed(p_speed_V2,offset_speed_V2),
                       required_distance_V2 <- eval_rd(fake_speed(p_speed_V2,offset_speed_V2)),
                       safety_gap_V1_V2 <- p_distance_V1_V2 - eval_rd(fake_speed(p_speed_V2,offset_speed_V2))]@(TIMER-1);

perturbation p_ItFast = ([offset_speed_V1 <- p_speed_V1 * MAX_SPEED_OFFSET * R[0,1]]@0); (p_fast)^150;

perturbation p_fast = [offset_speed_V1 <- p_speed_V1 * MAX_SPEED_OFFSET * R[0,1],
                       s_speed_V1 <- fast_speed(p_speed_V1,offset_speed_V1),
                       required_distance_V1 <- eval_rd(fast_speed(p_speed_V1,offset_speed_V1)),
                       safety_gap_V1 <- p_distance_V1 - eval_rd(fast_speed(p_speed_V1,offset_speed_V1))]@(TIMER-1);

perturbation p_comb = ([offset_speed_V1 <- p_speed_V1 * MAX_SPEED_OFFSET * R[0,1],
                        offset_speed_V2 <- p_speed_V2 * MAX_SPEED_OFFSET * R[0,1]]@0);
                      ((p_fast)^3;(p_slow)^3)^50;

perturbation p_ItDistSens = ([offset_distance <- R[0,1] * MAX_DISTANCE_OFFSET]@0); (p_distSens)^300;

perturbation p_distSens = [offset_distance <- R[0,1] * MAX_DISTANCE_OFFSET,
                           s_distance_V1_V2 <- p_distance_V1_V2 * (1 + offset_distance),
                           s_distance_V2 <- p_distance_V2 * (1 + offset_distance),
                           safety_gap_V1_V2 <- p_distance_V1_V2 * (1 + offset_distance) - eval_rd(p_speed_V2),
                           safety_gap_V2 <- p_distance_V2 * (1 + offset_distance) - eval_rd(p_speed_V2)]@(TIMER-1);

formula atomic_slow = \D[exp_crash,p_ItSlow] <= ETA_slow;
formula eventually_slow = true \U[0,450] !atomic_slow;
formula phi_slow = !eventually_slow;

formula atomic_fast = \D[exp_crash,p_ItFast] <= ETA_fast;
formula eventually_fast = true \U[0,450] !atomic_fast;
formula phi_fast = !eventually_fast;

formula atomic_comb = \D[exp_crash,p_comb] <= ETA_comb;
formula eventually_comb = true \U[0,450] !atomic_comb;
formula phi_comb = !eventually_comb;

formula fast_and_slow = phi_fast && phi_slow;
formula phi_crash = !fast_and_slow || phi_comb;

formula atomic_crash_speed = \D[exp_crash_speed,p_ItDistSens] <= ETA_crash_speed;
formula eventually_crash_speed = true \U[0,450] !atomic_crash_speed;
formula phi_crash_speed = !eventually_crash_speed;

