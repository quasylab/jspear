param ACCELERATION = 1.0;
param BRAKE = 2.0;
param NEUTRAL = 0.0;
param TIMER_INIT = 5;
param DANGER = 1;
param OK = 0;
param INIT_SPEED_V1 = 25.0;
param INIT_SPEED_V2 = 25.0;
param MAX_SPEED = 40.0;
param MAX_SPEED_OFFSET = 0.2;
param INIT_DISTANCE_OBS_V1 = 10000.0;
param INIT_DISTANCE_V1_V2 = 5000.0;
param MAX_DISTANCE_OFFSET = 1.0;
param SAFETY_DISTANCE = 200.0;
param ETA_fast = 0.05;
param ETA_slow = 0.1;
param ETA_comb = 0.1;
param ETA_CRASH_SPEED = 0.01;

type accel_type = ACCELERATION|NEUTRAL|BRAKE;

global variables{
  real p_speed_V1 range [0,MAX_SPEED] = INIT_SPEED_V1;
  real p_distance_V1 range [0,INIT_DISTANCE_OBS_V1] = INIT_DISTANCE_OBS_V1;
  int timer_V1 range [0,TIMER_INIT] = 0;
  real braking_distance_V1 range [0, INIT_DISTANCE_OBS_V1] = (INIT_SPEED_V1^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V1 * TIMER_INIT))/(2 * BRAKE);
  real required_distance_V1 range [0, INIT_DISTANCE_OBS_V1] = (INIT_SPEED_V1^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V1 * TIMER_INIT))/(2 * BRAKE) + SAFETY_DISTANCE;
  real safety_gap_V1 range [0, INIT_DISTANCE_OBS_V1] = INIT_DISTANCE_OBS_V1 - (INIT_SPEED_V1^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V1 * TIMER_INIT))/(2 * BRAKE) + SAFETY_DISTANCE;
  int crashed_V1 range [0,1] = 0;
  real p_speed_V2 range [0,MAX_SPEED] = INIT_SPEED_V2;
  real p_distance_V2 range [0,INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2] = INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2;
  real p_distance_V1_V2 range [0,INIT_DISTANCE_V1_V2] = INIT_DISTANCE_V1_V2;
  int timer_V2 range [0,TIMER_INIT] = 0;
  real braking_distance_V2 range [0, INIT_DISTANCE_V1_V2] = (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT))/(2 * BRAKE);
  real required_distance_V2 range [0, INIT_DISTANCE_V1_V2] = (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT))/(2 * BRAKE) + SAFETY_DISTANCE;
  real safety_gap_V2 range [0, INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2] = INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2 - (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT))/(2 * BRAKE) + SAFETY_DISTANCE;
  real safety_gap_V1_V2 range [0, INIT_DISTANCE_V1_V2] = INIT_DISTANCE_V1_V2 - (INIT_SPEED_V2^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * INIT_SPEED_V2 * TIMER_INIT))/(2 * BRAKE) + SAFETY_DISTANCE;
}


component Vehicle1 {
  variables{
    real s_speed_V1 range [0,MAX_SPEED] = p_speed_V1;
    real s_distance_V1 range [0,INIT_DISTANCE_OBS_V1] = p_distance_V1;
    accel_type accel_V1 = NEUTRAL;
    int warning_V1 range [0,1] = 0;
    int brake_light_V1 range [0,1] = 0;
    int crashed_V1 range [0,1] = 0;
  }
  controller {
    state Ctrl_V1 {
      if (s_speed_V1 > 0) {
        if (safety_gap_V1 > 0) {
          accel_V1 = ACCELERATION;
          timer_V1 = TIMER_INIT;
          brake_light_V1 = 0;
          exec Accelerate_V1;
        } else {
          accel_V1 = - BRAKE;
          timer_V1 = TIMER_INIT;
          brake_light_V1 = 1;
          exec Decelerate_V1;
        }
      } else {
        accel_V1 = NEUTRAL;
        timer_V1 = TIMER_INIT;
        exec Stop_V1;
      }
    }
    state Accelerate_V1 {
      if (timer_V1 > 0) {
        step Accelerate_V1;
      } else {
        exec Ctrl_V1;
      }
    }
    state Decelerate_V1 {
      if (timer_V1 > 0) {
        step Decelerate_V1;
      } else {
        exec Ctrl_V1;
      }
    }
    state Stop_V1 {
      if (timer_V1 > 0) {
        step Stop_V1;
      } else {
        if (warning_V1 == DANGER) {
          accel_V1 = -BRAKE;
          timer_V1 = TIMER_INIT;
          exec Decelerate_V1;
        } else {
          timer_V1 = TIMER_INIT;
          exec Stop_V1;
        }
      }
    }
    state IDS_V1 {
      if (p_distance_V1 <= 2*TIMER_INIT*SAFETY_DISTANCE && (accel_V1 == ACCELERATION || (accel_V1 == NEUTRAL && p_speed_V1 > 0.0))) {
        warning_V1 = DANGER;
        exec IDS_V1;
      } else {
        warning_V1 = OK;
        exec IDS_V1;
      }
    }
  }
  init Ctrl_V1 || IDS_V1;
}

component Vehicle2 {
  variables{
    real s_speed_V2 range [0,MAX_SPEED] = p_speed_V2;
    real s_distance_V2 range [0,INIT_DISTANCE_OBS_V1 + INIT_DISTANCE_V1_V2] = p_distance_V2;
    real s_distance_V1_V2 range [0,INIT_DISTANCE_V1_V2] = p_distance_V1_V2;
    accel_type accel_V2 = NEUTRAL;
    int warning_V2 range [0,1] = 0;
    int brake_light_V2 range [0,1] = 0;
    int crashed_V2 range [0,1] = 0;
  }
  controller {
    state Ctrl_V2 {
      if (s_speed_V2 > 0) {
        if (safety_gap_V1_V2 > 0 && (brake_light_V1 == 0 || (s_distance_V1_V2 >= 300 && safety_gap_V2 > 0 ))) {
          accel_V2 = ACCELERATION;
          timer_V2 = TIMER_INIT;
          brake_light_V2 = 0;
          exec Accelerate_V2;
        } else {
          accel_V2 = - BRAKE;
          timer_V2 = TIMER_INIT;
          brake_light_V2 = 1;
          exec Decelerate_V2;
        }
      } else {
        accel_V2 = NEUTRAL;
        timer_V2 = TIMER_INIT;
        exec Stop_V2;
      }
    }
    state Accelerate_V2 {
      if (timer_V2 > 0) {
        step Accelerate_V2;
      } else {
        exec Ctrl_V2;
      }
    }
    state Decelerate_V2 {
      if (timer_V2 > 0) {
        step Decelerate_V2;
      } else {
        exec Ctrl_V2;
      }
    }
    state Stop_V2 {
      if (timer_V2 > 0) {
        step Stop_V2;
      } else {
        if (warning_V2 == DANGER) {
          accel_V2 = -BRAKE;
          timer_V2 = TIMER_INIT;
          exec Decelerate_V2;
        } else {
          timer_V2 = TIMER_INIT;
          exec Stop_V2;
        }
      }
    }
    state IDS_V1 {
      if (p_distance_V2 <= 2*TIMER_INIT*SAFETY_DISTANCE && (accel_V2 == ACCELERATION || (accel_V2 == NEUTRAL && p_speed_V2 > 0.0))) {
        warning_V2 = DANGER;
        exec IDS_V2;
      } else {
        warning_V2 = OK;
        exec IDS_V2;
      }
    }
  }
  init Ctrl_V2 || IDS_V2;
}

environment {
  let
    travel_V1 = accel_V1/2 + p_speed_V1;
  and
    travel_V2 = accel_V2/2 + p_speed_V2;
  in
    timer_V1' = timer_V1 - 1;
    p_speed_V1' = min(MAX_SPEED, max(0, p_speed_V1 + accel_V1));
    p_distance_V1' = p_distance_V1 - travel_V1;
    timer_V2' = timer_V2 - 1;
    p_speed_V2' = min(MAX_SPEED, max(0, p_speed_V2 + accel_V2));
    p_distance_V2' = p_distance_V2 - travel_V2;
    p_distance_V1_V2' = p_distance_V1_V2 - travel_V2 + travel_V1;
    if (timer_V1' == 0) {
      braking_distance_V1' = p_speed_V1'^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * p_speed_V1' * TIMER_INIT)) / (2 * BRAKE);
      required_distance_V1' = braking_distance_V1' + SAFETY_DISTANCE;
      safety_gap_V1' = p_distance_V1' - required_distance_V1';
      s_speed_V1' = p_speed_V1';
      s_distance_V1' = p_distance_V1';
    }
    if (timer_V2' == 0) {
      braking_distance_V2' = p_speed_V2'^2 + (ACCELERATION + BRAKE) * (ACCELERATION * TIMER_INIT^2 + 2 * p_speed_V2' * TIMER_INIT)) / (2 * BRAKE);
      required_distance_V2' = braking_distance_V2' + SAFETY_DISTANCE;
      safety_gap_V2' = p_distance_V2' - required_distance_V2';
      safety_gap_V1_V2' = p_distance_V1_V2' - required_distance_V2';
      s_speed_V2' = p_speed_V2';
      s_distance_V2' = p_distance_V2';
      s_distance_V1_V2' = p_distance_V1_V2';
    }
    when (p_distance_V1 <= 0)
      crashed_V1' = 1;
    when (p_distance_V2 <= 0 || p_distance_V1_V2 <=0)
      crashed_V2' = 1;
}




