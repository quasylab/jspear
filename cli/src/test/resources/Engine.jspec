param MIN_TEMP = 0;
param MAX_TEMP = 120;
param STRESS_INCR = 0.1;
param LOW = 0;
param HALF = 1;
param FULL = 2;
param OK = 0;
param HOT = 1;
param INITIAL_TEMP = 95.0;

param TAU = 100;
param K = 100;
param H = 1000;

param TEMP_OFFSET = -1.5;
param ETA_1 = 0.0;
param ETA_2 = 0.02;
param ETA_3 = 0.05;
param ETA_4 = 0.3;

param COOL_ATTACK = 1.8;
param ZETA_1 = 0.5;
param ZETA_2 = 0.3;

variables {
  real p1 range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  real p2 range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  real p3 range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  real p4 range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  real p5 range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  real p6 range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  real stress range [0,1] = 0.0;
  real temp range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
  bool cool = false;
  int speed = HALF;
  real fn = 0.0;
  int time_step = 0;
}


function temperatureUpdateInOneStep(bool cool, int speed) {
  if (cool) {
    return R[-1.2, -0.8];
  } else {
    if (speed == LOW ){
      return R[0.1, 0.3];
    } else {
      if (speed == HALF) {
        return R[0.3, 0.7];
      } else {
        return R[0.7, 1.2];
      }
    }
  }
}

function partialStress (real a){
  if (a>100) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function isStressed (real a1, real a2, real a3, real a4, real a5, real a6) {
  return partialStress(a1) + partialStress(a2) + partialStress(a3) + partialStress(a4) + partialStress(a5) + partialStress(a6);
}

function pen_temp (real temperature1, real temperature2) {
  return abs(temperature1 - temperature2)/abs(MAX_TEMP - MIN_TEMP);
}


function pert_cool (real temperature1, bool cooler) {
  if (temperature1 >= 99.8-COOL_ATTACK) {
    return cooler;
  } else {
    return false;
  }
}



component Engine{
    variables{
        real ch_temp range [MIN_TEMP, MAX_TEMP] = INITIAL_TEMP;
        int ch_wrn = OK;
        int ch_speed = HALF;
        int ch_out = HALF;
        int ch_in = HALF;
    }
    controller {
        state Ctrl {
            if (ch_temp >= 99.8) {
                cool' = true;
                step Cooling;
            } else {
            exec Check;
            }
        }
        state Check {
            if (ch_speed == LOW) {
                speed' = LOW;
                cool' = false;
                step Ctrl;
            } else {
                speed' = ch_in;
                cool' = false;
                step Ctrl;
            }
        }
        state Cooling {
            4#step Check;
        }
        state IDS {
            if (temp>101.0 & !cool) {
                ch_wrn' = HOT;
                ch_speed' = LOW;
                ch_out' = FULL;
                step IDS;
            } else {
                ch_wrn' = OK;
                ch_speed' = HALF;
                ch_out' = HALF;
                step IDS;
            }
        }
    }
    init Ctrl || IDS
}

environment {
    temp' = temp + temperatureUpdateInOneStep(cool, speed);
    ch_temp' = ch_temp + temperatureUpdateInOneStep(cool, speed);
    fn' = (time_step*fn + max(0.0, stress - ch_wrn))/(1+time_step);
    time_step' = time_step + 1;
    p1' = temp;
    p2' = p1;
    p3' = p2;
    p4' = p3;
    p5' = p4;
    p6' = p5;
    if (isStressed(p1,p2,p3,p4,p5,p6) > 3) {
      stress' = stress + STRESS_INCR;
    }
}



penalty rho_temperature = pen_temp(temp,ch_temp)

penalty rho_warning = ch_wrn

penalty rho_stress = stress

penalty rho_fn = fn



distance expr_temperature = < rho_temperature;

distance expr_warning = < rho_warning;

distance expr_stress = < rho_stress;

distance min_temperature = \F[TAU,TAU+K-1] expr_temperature;

distance max_temperature = \G[TAU,TAU+K-1] expr_temperature;

distance max_warning = \G[TAU,TAU+K+10] expr_warning;

distance max_stress = \G[TAU,TAU+K+10] expr_stress;

distance expr_false_negative = < rho_fn;

distance condition_1 = expr_stress <= ZETA_1;

distance condition_2 = expr_warning >= ZETA_2;

distance until_dist = condition_1 \U[0,TAU+K+10] condition_2;



perturbation fake_temperature = [ch_temp <- temp * TEMP_OFFSET * R[0,1]]@0;

perturbation it_fake_temperature = [fn <- fn]@100;fake_temperature^K;

perturbation fake_cooling = ([cool <- pert_cool(temp,cool)]@0)^K;



formula phi_1 = \D[min_temperature,it_fake_temperature] >= ETA_1;

formula phi_2 = \D[max_temperature,it_fake_temperature] <= ETA_2;

formula phi_3 = \D[max_warning,it_fake_temperature] <= ETA_3;

formula phi_4 = \D[max_stress,it_fake_temperature] > ETA_4;

formula phi_5 = phi_1 && phi_2;

formula phi_6 = phi_3 && phi_4;

formula phi_7 = !phi_5 || phi_6;

formula phi = \F[0,H] phi_7;


formula psi_1 = \D[until_dist, fake_cooling] < 1;

formula psi = psi_1 \U[0,H] \D[expr_false_negative, fake_cooling] <= ETA_3;
