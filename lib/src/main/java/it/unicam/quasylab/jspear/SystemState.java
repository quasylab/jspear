/*
 * JSpear: a SimPle Environment for statistical estimation of Adaptation and Reliability.
 *
 *              Copyright (C) 2020.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *             http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package it.unicam.quasylab.jspear;

import it.unicam.quasylab.jspear.ds.DataState;
import it.unicam.quasylab.jspear.ds.DataStateExpression;
import it.unicam.quasylab.jspear.ds.DataStateFunction;
import org.apache.commons.math3.random.RandomGenerator;

import java.util.Arrays;
import java.util.Optional;
import java.util.function.Function;

/**
 * This interface is implemented to define different models.
 */
public interface SystemState {

    /**
     * Returns the data state associated with this state.
     *
     * @return the data state associated with this state.
     */
    DataState getDataState();

    /**
     * Returns one state sampled among the one reachable from this state in one step.
     *
     * @param rg random generator used sample random expression.
     * @return one state sampled among the one reachable from this state in one step.
     */
    SystemState sampleNext(RandomGenerator rg);

    /**
     * Returns the system state where the data state is replaced with the given one.
     *
     * @param dataState new data state.
     * @return the system state where the data state is replaced with the given one.
     */
    SystemState setDataState(DataState dataState);


    /**
     * Returns the sampling of the given expression applied to this system state.
     *
     * @param rg random generator used in the sampling
     * @param function random expression to sample
     * @return the sampling of the given expression applied to this system state.
     */
    default SystemState apply(RandomGenerator rg, DataStateFunction function) {
        return this.setDataState(function.apply(rg, this.getDataState()));
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code>. At each step, <code>size</code> values are sampled.
     *
     * @param rg random generator used in the sampling
     * @param f function to evaluate
     * @param system initial state
     * @param steps number of steps
     * @param size number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, SystemState system, int steps, int size) {
        return sample(rg, f, rgn -> system , steps, size);
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code>. At each step, <code>size</code> values are sampled.
     *
     * @param rg random generator used in the sampling
     * @param f function to evaluate
     * @param generator initial state genertor
     * @param steps number of steps
     * @param size number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[] result = new double[steps];
        for(int i=0; i<steps; i++) {
            result[i] = Arrays.stream(current.evalPenaltyFunction(f)).average().orElse(Double.NaN);
            current = current.apply(s -> s.sampleNext(rg));
        }
        return result;
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>. At each step, <code>size</code> values are sampled.
     *
     * @param rg random generator used in the sampling
     * @param f function to evaluate
     * @param p applied perturbation
     * @param system initial state
     * @param steps number of steps
     * @param size number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, Perturbation p, SystemState system, int steps, int size) {
        return sample(rg, f, p, r -> system, steps, size);
    }
    /**
     * Computes the average values obtained by applying two given functions experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>. At each step, <code>size</code> values are sampled.
     *
     * @param rg random generator used in the sampling
     * @param f1 first function to evaluate
     * @param f2 second function to evaluate
     * @param p applied perturbation
     * @param system initial state
     * @param steps number of steps
     * @param size number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample(RandomGenerator rg, DataStateExpression f1, DataStateExpression f2, Perturbation p, SystemState system, int steps, int size) {
        return sample(rg, f1, f2, p, r -> system, steps, size);
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code> under the
     * perturbation <code>p</code>. At each step, <code>size</code> values are sampled.
     *
     * @param rg random generator used in the sampling
     * @param f function to evaluate
     * @param p applied perturbation
     * @param generator initial state generator
     * @param steps number of steps
     * @param size number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, Perturbation p, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[] result = new double[steps];
        for(int i=0; i<steps; i++) {
            Optional<DataStateFunction> perturbationEffects = p.effect();
            if (perturbationEffects.isPresent()) {
                current = current.apply(s -> s.apply(rg, perturbationEffects.get()));
            }
            result[i] = Arrays.stream(current.evalPenaltyFunction(f)).average().orElse(Double.NaN);
            current = current.apply(s -> s.sampleNext(rg));
            p = p.step();
        }
        return result;
    }

    /**
     * Computes the average values obtained by applying two given functions experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code> under the
     * perturbation <code>p</code>. At each step, <code>size</code> values are sampled.
     *
     * @param rg random generator used in the sampling
     * @param f1 first function to evaluate
     * @param f2 second function to evaluate
     * @param p applied perturbation
     * @param generator initial state generator
     * @param steps number of steps
     * @param size number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample(RandomGenerator rg, DataStateExpression f1, DataStateExpression f2, Perturbation p, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[][] result = new double[steps][2];
        for(int i=0; i<steps; i++) {
            Optional<DataStateFunction> perturbationEffects = p.effect();
            if (perturbationEffects.isPresent()) {
                current = current.apply(s -> s.apply(rg, perturbationEffects.get()));
            }
            result[i][0] = Arrays.stream(current.evalPenaltyFunction(f1)).average().orElse(Double.NaN);
            result[i][1] = Arrays.stream(current.evalPenaltyFunction(f2)).average().orElse(Double.NaN);
            current = current.apply(s -> s.sampleNext(rg));
            p = p.step();
        }
        return result;
    }

}
